export default {
    content :'#### 元素与组件 Element & Component\n\n##### React元素\n元素是构建React应用的描述界面的最小单位，在作用上，我们可以把React元素理解为DOM元素，但实际中，React元素只是js中普通的对象。在React内部有一套React DOM的机制，我们可以称之为Virtual DOM，通过js中树状结构的对象来模拟真实DOM。\nReact之所以轻和快就是因为这虚拟DOM的存在，React内部还实行了一个低复杂度高效率的Diff算法。不同于以往的框架如Angular使用的脏检查，在应用改版数据的时候，React会尽量进行少的比较，然后更具虚拟DOM只改变真实DOM当中需要被改变的部分。\n通过这成单独抽象的逻辑，让React有了无限的可能，例如ReactNative、ReactVR、ReactXP的实现。\n\n##### 组件\n组件是可以讲UI切分称为一些独立的、可服用的部分，类似于js当中对function函数的定义。\n\n#### 函数定义与类定义组件 Functional & Class\n新版本的React里提供了两种定义组件的方法\n\n* 通过JS的function来定义组件\n* 通过ES6中的class来定义组件\n\n函数定义组件需要定义一个接收props作为参数，返回react元素的方法即可。\n\n```javascript\nimport React from \'reat\'\nimport ReactDOM from \'react-dom\'\n\nconst Title = (props) => <h1>hello,{props.name}</h1>\nReactDOM.render(<Title name=\'react\' />,\n    document.getElementById(\'app\')\n);\n```\n\n类定义组件使用ES6中class类的方法来定义\n\n```javascript\nimport React from \'reat\'\nimport ReactDOM from \'react-dom\'\n\nclass Title extends React.Component {\n    render() {\n        return <h1>hello,{props.name}</h1>\n    }\n}\nReactDOM.render(<Title name=\'react\' />,\n    document.getElementById(\'app\')\n);\n```\n\n#### 展示与容器组件 Presentational & Container\n\n* 展示组件主要负责组件内容如何展示，数据来自props或者与数据无关的state，大多情况使用函数声明组件\n* 容器组件主要关注数据如何交互，数据来自state和后端，多数使用class类声明组件\n\n这类组件负担的功能太多了，他只是一个单一的组件，同时需要初始化state，通过ajax获取服务器数据，渲染列表内容。在实际引用中可能还会有更多的功能依赖，在后续无论要修改样式内容、服务器交互都需要修改同一个组件，逻辑严重的耦合。如果功能在同一个组件维护，也不利于团队间的协作。\n\n```javascript\nimport React from \'reat\'\nimport ReactDOM from \'react-dom\'\n\n\nclass CommentList extends React.Component{\n    contructor(props) {\n        super(props)\n        this.state = {\n            comments:[]\n        }\n    }\n    \n    componentDidMount() {\n        $.ajax({\n            url:\'my-contents.json\',\n            dataType:\'json\',\n            sucess:function(comments){\n                this.setState({\n                    coments:coments\n                })\n            }.bind(this)\n        })\n    }\n    \n    renderComment({body,author}) {\n        return <li>{body}-{author}</li>\n    }\n    \n    render() {\n        renturn <ul>{this.state.comments.map(this.renderComment)}</ul>\n    }\n    \n}\n\n```\n\n区分展示组件和容器组件。回复列表如何展示、如何获取的逻辑就被分离到2个组件中。\n\n```javascript\nimport React from \'reat\'\nimport ReactDOM from \'react-dom\'\n\n\n//展示组件\nclass CommentList extends React.Component {\n    contruct(props) {\n        super(props)\n    }\n    \n    renderComment({body,author}) {\n        return <li>{body}-{author}</li>\n    }\n    \n    render() {\n        renturn <ul>{this.state.comments.map(this.renderComment)}</ul>\n    }\n}\n\n//容器组件\nclass CommentListContainer extends React.Component {\n    contructor() {\n        super()\n        this.state = {\n            comments:[]\n        }\n    }\n    \n    componentDidMount() {\n        $.ajax({\n            url:\'my-contents.json\',\n            dataType:\'json\',\n            sucess:function(comments){\n                this.setState({\n                    coments:coments\n                })\n            }.bind(this)\n        })\n    }\n    \n    render() {\n        return <CommentList comtents={this.state.comments} />\n    }\n}\n```\n\n#### 有状态与无状态组件 Stateful & Stateless\n* 有状态组件可以获取、存储、改变引用本身的数据，伴有state的变化。\n* 无状态组件只接收来自其他组件的传值，只对this.props的调用。\n* 并不是所有的展示组件都是无状态组件，所有的容器组件都是有状态组件。\n\n```javascript\nimport React from \'reat\'\nimport ReactDOM from \'react-dom\'\n\n//有状态组件\nclass StatefullLink extends React.Component {\n    constructor(props) {\n        super(props)\n        this.state = {\n            active:false\n        }\n    }\n    \n    handleClick() {\n        this.setState({\n            active: !this.state.active\n        })\n    }\n    \n    render() {\n        return <a\n            style={{ color: this.state.active ? \'red\' : \'black\' }}\n            onClick={this.handleClick.bind(this)}\n        >\n            Stateful Link\n        </a>\n    }\n}\n\n// 无状态组件\nclass StatelessLink extends React.Component {\n    contructor(props) {\n        super(props)\n    }\n    \n    handleClick() {\n        this.props.handleClick(this.props.router)\n    }\n    \n    render() {\n        const active = this.props.activeRouter === this.props.router\n        return (\n            <li>\n                <a\n                    style={{ color : active ? \'red\' : \'black\' }}\n                    onClick={this.handleClick.bind(this)}\n                >\n                    Stateless Link\n                </a>\n            </li>\n        )\n    }\n}\n```\n\n事实上我们编写的组件大部分都是无状态组件\n\n```javascript\nimport React from \'reat\'\nimport ReactDOM from \'react-dom\'\n\nfunction SimpleButtonES5(props) {\n    return <button>{props.text}</button>\n}\n\nconst SimpleButtonES6 = props => <button{props.text}</button>\n```\n\n#### 受控与非受控组件 Controlled & Uncontrolled\n一般涉及到表单元素时对组件类型的划分方法\n\n* 一般情况下所有React表单元素都是受控组件，每个受控组件都需要对应的事件处理函数\n* React通过特殊属性ref来获取非受控组件\n\n受控组件的值一般由props或者state传入，用户在元素上交互或者输入内容会引起state的变化，在state改变之后重新渲染组件，我们才能在页面中看到值的变化。假如没有绑定事件处理函数，用户的输入是不会有效果的，这就是受控的含义所在。\n\n```javascript\nclass ControlledInput extends React.Component {\n    constructor() {\n        super()\n        this.state = {\n            value:\'Please type here...\'\n        }\n    }\n    \n    handleChange(event){\n        console.log(\'Controlled change:\',event.target.value)\n        this.setState({\n            value:event.target.value\n        })\n    }\n    \n    render() {\n        return (\n            <label>\n                Controlled Component:\n                <input type=\"text\" value={this.state.value} onChange={(e)=> this.handleChange(e)}/>\n            </label>\n        )\n    }\n}\n```\n\n非受控组件类似于传统的DOM表单控件，用户输入不会引起static的改变，我们也不会直接为非受控组件传入值。获取非受控组件的值我们需要使用特殊的ref属性，\n\n```javascript\nclass UncontrolledInput extends React.Component {\n    constructor() {\n        super()\n    }\n    \n    handleChange(event){\n        console.log(\'Controlled change:\',event.target.value)\n    }\n    \n    render() {\n        return (\n            <label>\n                Uncontrolled Component:\n                <input type=\"text\" defaultValue=\'Please type here...\' ref={(input)=> this.input = input} onChange={(e)=> this.handleChange(e)}/>\n            </label>\n        )\n    }\n}\n```\n\n通常情况下，react当中所有的表单控件都需要是受控组件，我们需要为每一个受控组件编写事件处理函数。比如说注册，你需要写出所有姓名、电话、邮箱的逻辑。当然也有小技巧可以让同一个事件处理函数引用在多个表单组件中，但生产开发中并没有多大的意义，多是在重构的时候使用。还有一些别的库，需要和表单进行交互，这时候使用非受控组件就会方便一些。\n\n#### 组合与继承 Composition & Inheritance\n* 通过组合和props传值几乎可以满足所有的场景需求，同样也更符合组件化的理念，就好像相互嵌套的DOM元素一样。\n* 继承的写法虽然生效，但是不符合React的理念，在React中，props可以传入任何东西：变量、函数、甚至是组件本身。\n\n```javascript\nimport React from \'reat\'\nimport ReactDOM from \'react-dom\'\n\nclass InheritedButton extends React.Component {\n    contructor() {\n        super()\n        this.state = {\n            color: \'red\'\n        }\n    }\n    \n    render() {\n        return (\n            <button style={{backgroundColor: this.state.color}} >Inherited Button</button>\n        )\n    }\n}\n\nclass BlueButton extends InheritedButton {\n    contructor() {\n        super()\n        this.state = {\n            color:\'blue\'\n        }\n    }\n}\n\nconst CompositedButton = props => <button style={{backgroundColor:props.color}}Composited Button</button>\nconst YellowButton = () =>  <CompositedButton color=\"yellow\" />\n\nReactDOM.render(\n    <div>\n        <BlueButton/>\n        <br/>\n        <YellowButton>\n    </div>,\n    document.getElementById(\'app\')\n)\n\n```\n\n如何想实现一些非洁面类型函数的服用，可以单独写在其他的模块当中，再引入组件进行使用。',
}